#!/bin/bash

# Oracle Database Size Checker Script
# Discovers Oracle databases from running pmon processes and checks PDB sizes

# Check if script is running as odb4si user
if [ "$(whoami)" != "odb4si" ]; then
    echo "ERROR: This script must be executed as odb4si user" >&2
    echo "Current user: $(whoami)" >&2
    exit 1
fi

# Color codes for output formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_header() {
    echo -e "${BLUE}================================================================${NC}" >&2
    echo -e "${BLUE}           Oracle Database Size Checker${NC}" >&2
    echo -e "${BLUE}================================================================${NC}" >&2
}

print_info() {
    echo -e "${BLUE}[INFO]${NC} $1" >&2
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" >&2
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1" >&2
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Function to discover Oracle databases from pmon processes
discover_databases() {
    # Get pmon processes and extract database names 
    # Format: ora_pmon_C03M10FM_1 -> extract C03M10FM_1, strip RAC suffix (_1), then convert to lowercase
    databases=$(ps -ef | grep pmon | grep -v grep | grep -iEv 'asm|apx|mgmtdb' | grep -o 'ora_pmon_[^[:space:]]*' | sed 's/ora_pmon_//' | sed 's/_[0-9]*$//' | tr '[:upper:]' '[:lower:]' | grep -v '^$' | grep -v '^//' | sort -u)
    
    if [ -z "$databases" ]; then
        exit 1
    fi
    
    echo "$databases"
}

# Function to source Oracle environment with fallbacks
source_oracle_env() {
    local db_name=$1
    
    # Source Oracle environment files in priority order
    for env_file in "/home/oracle/dba_${db_name}.env" \
                    "/home/oracle/${db_name}.env" \
                    "/home/oracle/.${db_name}"; do
        if [ -f "$env_file" ]; then
            . "$env_file" 2>/dev/null
            return 0
        fi
    done
    
    # If no environment file found, try the user's approach
    if [ -f "$db_name" ]; then
        . "$db_name" 2>/dev/null
        return 0
    fi
    
    return 1
}

# Function to check if database is a CDB
check_if_cdb() {
    local temp_sql=$(mktemp --suffix=.sql)
    chmod 600 "$temp_sql"
    
    cat > $temp_sql << 'EOF'
SET PAGESIZE 0
SET FEEDBACK OFF
SET VERIFY OFF
SET HEADING OFF
SET ECHO OFF
SET LINESIZE 200
WHENEVER SQLERROR EXIT SQL.SQLCODE

SELECT cdb
FROM v$database;

EXIT;
EOF

    local cdb_result=$(sqlplus -L -s / as sysdba @$temp_sql 2>/dev/null)
    local sql_exit_code=$?
    rm -f $temp_sql
    
    if [ $sql_exit_code -eq 0 ] && [ "$cdb_result" = "YES" ]; then
        echo "YES"
    else
        echo "NO"
    fi
}

# Function to get PDBs information
get_pdbs_info() {
    local temp_sql=$(mktemp --suffix=.sql)
    chmod 600 "$temp_sql"
    
    cat > $temp_sql << 'EOF'
SET PAGESIZE 0
SET FEEDBACK OFF
SET VERIFY OFF
SET HEADING OFF
SET ECHO OFF
SET LINESIZE 200
WHENEVER SQLERROR EXIT SQL.SQLCODE

SELECT name||'|'||open_mode
FROM v$pdbs
ORDER BY name;

EXIT;
EOF

    local pdbs_info=$(sqlplus -L -s / as sysdba @$temp_sql 2>/dev/null)
    local sql_exit_code=$?
    rm -f $temp_sql
    
    if [ $sql_exit_code -eq 0 ]; then
        echo "$pdbs_info"
    else
        echo ""
    fi
}

# Main function to get database and PDB sizes
get_pdb_sizes() {
    local db_name=$1
    
    # Skip empty database names
    if [ -z "$db_name" ]; then
        return 1
    fi
    
    # Source the Oracle environment with fallbacks
    if ! source_oracle_env "$db_name"; then
        printf "%-15s %-20s %-10s %-10s %-15s %-15s\n" "$db_name" "-" "ERROR" "Cannot connect" "-" "-"
        return 1
    fi
    
    # Step 1: Check if database is CDB with lightweight query
    local is_cdb=$(check_if_cdb)
    
    # Step 2: Handle based on database type
    if [ "$is_cdb" = "YES" ]; then
        # Handle CDB - get PDBs info
        local pdbs_info=$(get_pdbs_info)
        
        if [ -n "$pdbs_info" ]; then
            # Process each PDB
            local temp_pdb_file=$(mktemp)
            echo "$pdbs_info" > "$temp_pdb_file"
            
            while IFS='|' read -r pdb_name open_mode; do
                # Skip empty lines
                [ -z "$pdb_name" ] && continue
                
                # Print PDB info with CDB name
                printf "%-15s %-20s %-10s %-10s" "$db_name" "$pdb_name" "PDB"
                
                if [ "$open_mode" = "READ WRITE" ] || [ "$open_mode" = "READ ONLY" ]; then
                    printf " %-10s" "OPEN"
                    get_pdb_size $pdb_name
                elif [ "$open_mode" = "MOUNTED" ]; then
                    printf " %-10s" "MOUNTED"
                    printf " %-15s %-15s\n" "PDB is mounted" "-"
                else
                    printf " %-10s" "CLOSED"
                    printf " %-15s %-15s\n" "PDB is down" "-"
                fi
            done < "$temp_pdb_file"
        
        rm -f "$temp_pdb_file"
        else
            printf "%-15s %-20s %-10s %-10s %-15s %-15s\n" "$db_name" "-" "CDB" "OPEN" "No PDBs found" "-"
        fi
    elif [ "$is_cdb" = "NO" ]; then
        # Handle Non-CDB database
        get_non_cdb_size $db_name
    else
        printf "%-15s %-20s %-10s %-10s %-15s %-15s\n" "$db_name" "-" "ERROR" "Unknown type" "-" "-"
        return 1
    fi
}

# Function to get size for non-CDB database
get_non_cdb_size() {
    local db_name=$1
    
    local temp_sql=$(mktemp --suffix=.sql)
    chmod 600 "$temp_sql"
    
    cat > $temp_sql << 'EOF'
SET PAGESIZE 0
SET FEEDBACK OFF
SET VERIFY OFF
SET HEADING OFF
SET ECHO OFF
SET LINESIZE 200
WHENEVER SQLERROR EXIT SQL.SQLCODE

SELECT 
    ROUND(SUM(bytes)/1024/1024/1024, 2) || ' GB|' ||
    ROUND(SUM(CASE WHEN autoextensible = 'YES' THEN maxbytes ELSE bytes END)/1024/1024/1024, 2) || ' GB'
FROM dba_data_files;

EXIT;
EOF

    local size_info=$(sqlplus -L -s / as sysdba @$temp_sql 2>/dev/null)
    local sql_exit_code=$?
    rm -f $temp_sql
    
    if [ $sql_exit_code -eq 0 ] && [ -n "$size_info" ]; then
        local total_size max_size
        IFS='|' read total_size max_size <<< "$size_info"
        printf "%-15s %-20s %-10s %-10s %-15s %-15s\n" "$db_name" "$db_name" "NON-CDB" "OPEN" "$total_size" "$max_size"
    else
        printf "%-15s %-20s %-10s %-10s %-15s %-15s\n" "$db_name" "$db_name" "NON-CDB" "OPEN" "Error getting size" "-"
    fi
}

# Function to get PDB size using ALTER SESSION SET CONTAINER as shown by user
get_pdb_size() {
    local pdb_name=$1
    
    local temp_sql=$(mktemp --suffix=.sql)
    chmod 600 "$temp_sql"
    
    cat > $temp_sql << EOF
SET PAGESIZE 0
SET FEEDBACK OFF
SET VERIFY OFF
SET HEADING OFF
SET ECHO OFF
SET LINESIZE 200
SET TAB OFF
WHENEVER SQLERROR EXIT SQL.SQLCODE

ALTER SESSION SET CONTAINER = $pdb_name;

SELECT ROUND(SUM(bytes)/1024/1024/1024, 2) || ' GB|' || ROUND(SUM(CASE WHEN autoextensible = 'YES' THEN maxbytes ELSE bytes END)/1024/1024/1024, 2) || ' GB' FROM dba_data_files;

EXIT;
EOF

    local size_info=$(sqlplus -L -s / as sysdba @$temp_sql 2>/dev/null)
    # Filter to get only the line with size information
    size_info=$(echo "$size_info" | tr -d '\r' | grep 'GB|' | tail -n 1)
    local sql_exit_code=$?
    rm -f $temp_sql
    
    if [ $sql_exit_code -eq 0 ] && [ -n "$size_info" ]; then
        local total_size max_size
        IFS='|' read total_size max_size <<< "$size_info"
        printf " %-15s %-15s\n" "$total_size" "$max_size"
    else
        printf " %-15s %-15s\n" "Error getting size" "-"
    fi
}

# Main execution
main() {
    # Discover databases
    databases=$(discover_databases)
    
    if [ -z "$databases" ]; then
        exit 1
    fi
    
    # Print table header with CDB name column
    printf "%-15s %-20s %-10s %-10s %-15s %-15s\n" "CDB_NAME" "DATABASE/PDB" "TYPE" "STATUS" "CURRENT SIZE" "MAX SIZE"
    printf "%-15s %-20s %-10s %-10s %-15s %-15s\n" "---------------" "--------------------" "----------" "----------" "---------------" "---------------"
    
    # Process each database
    for db in $databases; do
        get_pdb_sizes $db
    done
}

# Execute main function
main "$@"